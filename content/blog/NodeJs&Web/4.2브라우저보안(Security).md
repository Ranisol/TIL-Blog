---
title: (Web) 브라우저 보안(Security)
date: "2020-09-20"
description: 
---

# 1. Web에서의 보안 위협

## XSS(Cross Site Scripting)
**XSS**는 Client가 응답(Response)을 받을 때, **Client가 Response를 신뢰**하기 때문에 발생하는 문제
- 예를 들어, 사용자가 응답을 받을 때, 해커가 서버에 심어놓은 자바스크립트 코드가 사용자의 환경에서 실행되는 경우. 
- 기본적으로 브라우저에서 xss공격을 막고 있음. 하지만 모두 막고 있지는 않음

![image](https://www.imperva.com/learn/wp-content/uploads/sites/13/2019/01/sorted-XSS.png)



## CSRF(Cross-Site Request forgery)
**CSRF**는 Client가 요청(Request)할 때, **Server가 Request를 신뢰**하기 때문에 발생하는 문제.
- 예를 들어, 사용자가 요청을 할 때, 해커가 사용자의 인증정보를 가로채서 서버에 요청을 보내는 경우.
- 참고로 인증(authentication), 권한(Authorization)과 연관이 있는 개념.
![image](https://media.vlpt.us/images/josworks27/post/930ad5c1-00ec-4f79-a24f-885f3a362f2a/HowTheCSRFPerformed.jpg)


# 2. CORS(Cross-Origin Resourse Sharing)

## Origin = protocol + Host + 포트번호
먼저 출처(Origin)이라는게 무엇을 의미하는지?

**URL의 구성요소**의 앞에 두개와
![출처](https://evan-moon.github.io/static/e25190005d12938c253cc72ca06777b1/6af66/uri-structure.png)

url에는 생략되어있는 :80, :443와 같은 포트 번호까지 합친 것 의미. 
- 생략된 이유는 http, https와 같은 프로토콜에 따라, 기본 포트번호가 정해져 있기 때문이라고 함.

## SOP(Same-Origin Policy)
CORS와 같은 보안정책. 같은 출처의 리소스만을 공유할 수 있다는 규칙. 하지만 다른 출처의 리소스를 공유하는 일이 비일비재한 실제 환경에서는 비현실적인 제약. 

따라서 여러개의 예외 중 하나로 CORS인 경우를 설정해 둠으로써 어느정도 실현가능하게 됨.

## 출처가 다른게 왜 위험해?
출처(origin)가 다르다는게 왜 위험한지?
[security.stackexchange](https://security.stackexchange.com/questions/8264/why-is-the-same-origin-policy-so-important)에서는 동일한 출처 정책이 없다면, 악성 웹사이트가 자바스크립트 코드를 통해 마음대로 정보를 조작할 수 있다고 한다. 아마도 자바스크립트로 할 수 있는게 많아서 그런게 아닐까 한다. 단,  구체적으로 어떤식으로 조작이 일어나는지는 좀 더 공부해봐야 알듯.. 어쨌든 이러한 문제를 방지하기 위해 CORS와 같은 보안 정책이 마련되어 있음.


## 출처 같은지 판단하는 법?
url요소 중, Scheme, Host, Port이 세가지를 보고 판단함.

- Scheme: http / https와 같은 것을 의미.
	
    - 앞서 살펴본 protocol과 유사하다. scheme이 더 구체적인 값을 지정하는 것처럼 보이기는 하나, 구체적으로 어떠한 차이가 있는지는 잘 모르겠다. [stackoverflow](https://stackoverflow.com/questions/48953298/whats-the-difference-between-a-scheme-and-a-protocol-in-a-url)의 한 답변에 따르면, 스킴은 프로토콜의 식별자라고 말한다.

- Host

- Port

이렇게 세가지를 보고 판단하는데, 이는 브라우저 자체에 구현되어 있는 스펙이다. 즉, 서버가 정상적으로 응답한다고 하더라도, 정책 위반이라면 응답을 그냥 버린다.



# 3. CORS의 동작 방식
동작하는 방식에는 세 가지 시나리오가 있다. Simple request,  Preflighted request, Credentialed Request이 그것이다. 

## Simple request

![image](https://docs.tizen.org/application/web/guides/w3c/security/media/cors_simple.png)

## Preflighted request
![image](https://docs.tizen.org/application/web/guides/w3c/security/media/cors_preflight.png)
## Credentialed request



## 시나리오 Example
1. BP 은행의 고객 Alice가 로그인 함
2. Alice가 Bob에게 송금을 요청하는 api가 아래와 같다고 가정(말도 안되지만!!!)
GET http://bulletproofbank.com/transfer.do?recipient=Bob&amount=$500 HTTP/1.1
3. 공격자(Mallory)는 Alice가 자기에게 돈을 보내는 api 요청을 생성
GET http://bulletproofbank.com/transfer.do?recipient=attacker&amount=$500 HTTP/1.1
4. 낚시용 링크 전송(이메일, 쪽지, DM 등)
<a href="http://abcbank.com/transfer.do?recipient=Mallory&amount=$500">영화 (불지옥)반도 무료 티켓 2장 선착순!!</a> 

HTML sanitize: https://codepen.io/igotoweb/pen/MWyLJdY 
준비했습니다 

https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html 
https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html 

5. WAF(Web Application Firewall) 알아보기
https://avinetworks.com/what-is-a-web-application-firewall/ 
SCAN YOUR SITE(https://securityheaders.com)