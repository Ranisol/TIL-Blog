---
title: JSX with Array / key
date: "2020-10-04"
description: 
---

https://ko.reactjs.org/docs/react-component.html#setstate
https://ko.reactjs.org/docs/faq-state.html

## setState()
위의 예시에서 주의깊게 봐야할 점은 tick()의 setState()라는 메서드이다. 

state를 아래와 같이 직접 다루는 방식을 취하면, 컴포넌트를 다시 렌더링하지 않는다. 대신, setState()를 사용한다.
```js
// ...
  constructor(props) {
    super(props);
    this.state = '';
  }
// ...
this.state.comment = 'hello';    // X
this.setState({comment:'hello'}) // O
```



그리고 setState()는 다음 세가지 특징을 가지고 있다.

### 1) 비동기적이므로, 인자로 넘겨주기
this.props와 this.state는 [비동기적으로 업데이트](https://ko.reactjs.org/docs/faq-state.html) 될 수 있다고 한다. (정확히 어떤 식의 업데이트를 의미하는지는 모르겠다..)

따라서 외부의 state와 props에 직접 접근하는 다음 코드는 카운터 업데이트에 실패할 수 있다.
```js
this.setState({
  counter: this.state.counter + this.props.increment,
});
```
대신 다음의 코드는 제대로 작동한다. 아래 코드는 state와 props를 인자로 받아서 사용하기 때문에, 
```js
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```

이에 대해서는 [setState의 비동기성 파일](8.State끌어올리기setState비동기성.md)에서 다루고자 한다.

### 2) this.state의 변수를 독립적으로 업데이트
아래의 state에는 두가지 객체(posts, comments)가 있다.
```js
constructor(props) {
  super(props);
  this.state = {
    posts: [],
    comments: []
  };
}
```

아래에서는 setState를 호출해 posts와 comments에 대해 각각 업데이트를 진행한다.
```js
componentDidMount() {
  fetchPosts().then(response => {
    this.setState({
      posts: response.posts
    });
  });
  fetchComments().then(response => {
    this.setState({
      comments: response.comments
    });
  });
}
```
이렇게 업데이트를 진행하면, 객체 각각에 대해 업데이트를 진행하는 효과를 낳는다. 따라서 posts를 업데이트 할때는 posts 키의 값은 대체되지만, comments에 대해서는 변화를 주지 않는다.

### 3) state의 캡슐화와 자식에게의 props화
한 컴포넌트의 state는 다른 컴포넌트가 알 수 없다.

단, 부모 컴포넌트는 자신의 state를 자식 컴포넌트에 props로 전달할 수 있다.
```js
<FormattedDate date={this.state.date} />
```