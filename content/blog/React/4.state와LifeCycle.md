---
title: State와 생명주기 개념
date: "2020-10-03"
description: 
---

# 1. state vs props?

state는 props와 비슷하지만, 비공개이고 컴포넌트에 의해 제어가능하다. 

## props를 이용한 경우
```js
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
ReactDOM.render(
    <Clock date = {new Date()}/>,
    document.getElementById('root')
)
```

## props를 state로 바꾸기

state는 클래스의 constructor에서 만들어진 `property(this.state)`로 존재한다.

동시에 props도 존재하는데, react element를 만들때면 항상 props는 존재해야하는 탓인지, `super(props)`는 언제나 설정해줘야 한다.

```js
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

# 2. 생명주기
컴포넌트는 어떤 동작을 수행하는 경우가 있다. 타이머의 경우, 매 초, 매 분이 지날때마다 숫자를 바꿔주는 동작이 필요하다.

그런데, 이러한 동작은 컴포넌트가 등장했을 때나 필요하지, 컴포넌트가 사라진 상태에서는 필요없다. 만일 더 이상 필요 없음에도 내부에서는 열심히 일하고 있다면, 리소스를 잡아먹게 된다. 반대로 컴포넌트가 등장 전부터 동작할 필요도 없다. 등장 전부터 동작하고 있다면 마찬가지로 프로그램을 더 무겁게 만드는 원인이 된다.

따라서 컴포넌트가 수행해야 할 동작은 등장과 동시에 수행되기 시작하고, 사라짐으로써 동작을 멈춰야만 한다. 이렇게 `컴포넌트의 발생과 소멸, 그에 따른 동작 수행과 멈춤을 컴포넌트의 생명 주기`라고 한다.

위의 예시에서 컴포넌트에 생명 주기를 표현하자. 그럼 다음의 두 메서드가 필요할 것이다.

```js
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
  componentDidMount() {
  }
  componentWillUnmount() {
  }
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```



