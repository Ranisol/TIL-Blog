---
title: State와 생명주기 개념
date: "2020-10-03"
description: 
---

# 1. state vs props?

state는 props와 비슷하지만, 비공개이고 컴포넌트에 의해 제어가능하다. 

## props를 이용한 경우
```js
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
ReactDOM.render(
    <Clock date = {new Date()}/>,
    document.getElementById('root')
)
```

## props를 state로 바꾸기

state는 클래스의 생성자에서 this.state로 만들어준다. this.state를 사용하는 유일한 곳이다. 다른 부분에서 state에 변형을 가하려면 setState()를 사용해줘야 한다.

동시에 props도 존재하는데, react element를 만들때면 항상 props는 존재해야하는 탓인지, `super(props)`는 언제나 설정해줘야 한다.

```js
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

## state vs props와 비교
https://lucybain.com/blog/2016/react-state-vs-pros/

https://github.com/uberVU/react-guide/blob/master/props-vs-state.md


# 2. 생명주기
컴포넌트는 어떤 동작을 수행하는 경우가 있다. 타이머의 경우, 매 초, 매 분이 지날때마다 숫자를 바꿔주는 동작이 필요하다.

그런데, 이러한 동작은 컴포넌트가 등장했을 때나 필요하지, 컴포넌트가 사라진 상태에서는 필요없다. 만일 더 이상 필요 없음에도 내부에서는 열심히 일하고 있다면, 리소스를 잡아먹게 된다. 또한 컴포넌트가 등장 전부터 동작할 필요도 없다. 등장 전부터 동작하고 있다면 마찬가지로 프로그램을 더 무겁게 만드는 원인이 된다.

따라서 컴포넌트가 수행해야 할 동작은 등장과 동시에 수행되기 시작하고, 사라짐으로써 동작을 멈춰야만 한다. 이렇게 `컴포넌트의 발생과 소멸, 그에 따른 동작 수행과 멈춤을 컴포넌트의 생명 주기`라고 한다.


## 생명주기 메서드
위의 예시에서 컴포넌트에 생명 주기를 추가하자. 그럼 다음의 두 메서드가 필요할 것이다.

```js
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
  componentDidMount() {
  }
  componentWillUnmount() {
  }
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```
이렇게 컴포넌트의 동작을 제어하는 두 메서드를 `생명주기 메서드`라고 부른다.

### 동작 설정
```js
tick() {
  this.setState({
    date: new Date()
  });
}
componentDidMount() {
  this.timerID = setInterval(
    () => this.tick(),
    1000
  );
}
```

### 동작 분해
```js
componentWillUnmount() {
    clearInterval(this.timerID);
}
```

## setState()
위의 예시에서 주의깊게 봐야할 점은 tick()의 setState()라는 메서드이다. 

state를 아래와 같이 직접 다루는 방식을 취하면, 컴포넌트를 다시 렌더링하지 않는다. 대신, setState()를 사용한다.
```js
// ...
  constructor(props) {
    super(props);
    this.state = '';
  }
// ...
this.state.comment = 'hello';    // X
this.setState({comment:'hello'}) // O
```



그리고 setState()는 다음 세가지 특징을 가지고 있다.

### 1) 비동기적이므로, 인자로 넘겨주기
this.props와 this.state는 [비동기적으로 업데이트](https://ko.reactjs.org/docs/faq-state.html) 될 수 있다고 한다. (정확히 어떤 식의 업데이트를 의미하는지는 모르겠다..)

따라서 외부의 state와 props에 직접 접근하는 다음 코드는 카운터 업데이트에 실패할 수 있다.
```js
this.setState({
  counter: this.state.counter + this.props.increment,
});
```
대신 다음의 코드는 제대로 작동한다. 아래 코드는 state와 props를 인자로 받아서 사용하기 때문에, 
```js
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```

이에 대해서는 [setState의 비동기성 파일](8.State끌어올리기setState비동기성.md)에서 다루고자 한다.

### 2) this.state의 변수를 독립적으로 업데이트
아래의 state에는 두가지 객체(posts, comments)가 있다.
```js
constructor(props) {
  super(props);
  this.state = {
    posts: [],
    comments: []
  };
}
```

아래에서는 setState를 호출해 posts와 comments에 대해 각각 업데이트를 진행한다.
```js
componentDidMount() {
  fetchPosts().then(response => {
    this.setState({
      posts: response.posts
    });
  });
  fetchComments().then(response => {
    this.setState({
      comments: response.comments
    });
  });
}
```
이렇게 업데이트를 진행하면, 객체 각각에 대해 업데이트를 진행하는 효과를 낳는다. 따라서 posts를 업데이트 할때는 posts 키의 값은 대체되지만, comments에 대해서는 변화를 주지 않는다.

### 3) state의 캡슐화와 자식에게의 props화
한 컴포넌트의 state는 다른 컴포넌트가 알 수 없다.

단, 부모 컴포넌트는 자신의 state를 자식 컴포넌트에 props로 전달할 수 있다.
```js
<FormattedDate date={this.state.date} />
```