---
title: JSX with Array / key
date: "2020-10-04"
description: 
---

# 1. `Array를 포함한 JSX` 렌더링

```js
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
  <li>{number}</li>
);
ReactDOM.render(
  <ul>{listItems}</ul>,
  document.getElementById('root')
);
```

# 2. `Array를 포함한 JSX를 return하는 컴포넌트` 렌더링

## 이렇게 하면 안됨!
리스트 각 항목에 key를 넣어야 한다고 경고가 표시된다.
```js
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) => 
    <li>{number}</li>       // 이 부분에서 key값
  );
  return (
    <ul>{listItems}</ul>
  );
}
const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);
```
## JSX로 매핑시 key
listItems의 각 요소를 JSX로 mapping시, key를 다음과 같이 넣어줘야 한다.

```js
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <li key={number.toString()}> {number} </li> // 이 부분에서 key값
  );
  return (
    <ul>{listItems}</ul>
  );
}
const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);
```

## 컴포넌트로 매핑시 key

```js
function ListItem(props) {
  return <li>{props.value}</li>;
}
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <ListItem key={number.toString()} value={number} /> // 이 부분에서 key값
  );
  return (
    <ul> {listItems} </ul>
  );
}
const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);
```

참고로 위 코드의 listItems는 생략한 채, 바로 ul태그 사이에 넣은 인라인 형식으로도 처리할 수 있다.

```js
function NumberList(props) {
  const numbers = props.numbers;
  return (
    <ul>
      {numbers.map((number) =>
        <ListItem key={number.toString()}
                  value={number} />
      )}
    </ul>
  );
}
```


# 3. key란?

## key의 역할
key는 React가 어떤 항목을 변경, 추가, 삭제할지 식별하는 것을 돕는다. ([React공식문서-재조정](https://ko.reactjs.org/docs/reconciliation.html#recursing-on-children)) 

일단은 서로 구분이 안되는 JSX사이에 key를 넣어서 각각에 접근할 수 있게끔 의미를 부여하는 역할을 한다고 이해하면 되지 않을까 싶다.

## key 선택하기
먼저 key는 전체 영역에서 고유할 필요는 없다. 형제 사이에서만 고유하면 된다고 한다. 따라서 다음과 같은 코드가 가능하다.
```js
function Blog(props) {
  const sidebar = (
    <ul>
      {props.posts.map((post) =>
        <li key={post.id}> {post.title} </li>
      )}
    </ul>
  );
  const content = props.posts.map((post) =>
    <div key={post.id}>
      <h3>{post.title}</h3>
      <p>{post.content}</p>
    </div>
  );
  return (
    <div>
      {sidebar}
      <hr />
      {content}
    </div>
  );
}
const posts = [
  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
  {id: 2, title: 'Installation', content: 'You can install React from npm.'}
];
ReactDOM.render(
  <Blog posts={posts} />,
  document.getElementById('root')
);
```
- 위에서는 `sidebar`와 `content` 모두에서 들어온 props.posts.id를 key로 사용하는데, 서로 같은 부모를 공유하고 있지 않기 때문에 고유성을 위배하지 않는다.

단, 아무리 고유성을 가지더라도 index를 key로 사용하는 것에 대한 위험성이 있다고 한다. 다음을 참조([medium-index as a key is an anti-pattern](https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318))
또한 이것도 참고하면 좋음 [index를 key로 쓰면 안되는 이유](https://medium.com/sjk5766/react-%EB%B0%B0%EC%97%B4%EC%9D%98-index%EB%A5%BC-key%EB%A1%9C-%EC%93%B0%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-3ce48b3a18fb)

인덱스를 키로 쓴다는 것은 아래 처럼 key를 설정하는 것을 의미한다.
```js
const todoItems = todos.map((todo, index) =>
  // Only do this if items have no stable IDs
  <li key={index}> {todo.text}  </li>
);
```

위와 같이 작성하면 발생하는 문제로 모두 `데이터를 담는 그릇`과 `데이터`의 불일치가 발생할 수 있다는 점을 꼽는다. 

`데이터를 담는 그릇`이란, 위 링크의 예시들에서는 컴포넌트 내부의 state에 기록된 데이터를 의미한다. 내부 데이터가 바뀜에 따라, state는 바뀌게 된다. 그에 따라 우리가 의도하는 바는 당연히 `데이터`도 자신의 그릇을 따라 같이 이동하는 것이다.

하지만 실제 결과를 보면 index를 사용했을 때 결과와 우리가 의도한 바와 일치하지 않는다는 사실을 확인할 수 있다. 

이런 일이 발생하는 근본적인 이유는 state에 변화가 발생할 때마다, 컴포넌트를 re-rendering을 한다는 사실에 있다. rendering과정에서 index가 정해지기 때문에, state에 변화가 발생할 때마다 index를 새롭게 부여한다. 새롭게 부여된 index와 state간에 불일치가 발생하면, 우리가 의도하지 않았던 데이터 미스가 발생하는 것이다.

좋은 key는 데이터의 id라고 말한다. 이는 id는 state(또는 props)자체에 기록되어 있고, 서로 떨어져서 작동할 일이 없기 때문이다. 하지만 항상 id를 설정하진 않을텐데, 그럴 때는 다른 식별할 수 있는 좋은 방법이 있을까?