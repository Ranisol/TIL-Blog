---
title: (Javascript) 5.Dom
date: "2020-09-23"
description: 
---

**[Understanding Asynchronous JavaScript](https://blog.bitsrc.io/understanding-asynchronous-javascript-the-event-loop-74cd408419ff)을 읽고 번역 및 나름 이해해 정리한 내용입니다.**

자바스크립트는 한번에 한가지밖에 처리할 수 없는 싱글 스레드 언어이다. 그 말은 즉슨, 자바스크립트 엔진(V8)은 싱글스레드로 한 번에 한 가지 상태만을 처리할 수 있다는 뜻이다.

이는 자바스크립트 코드를 작성할 때, (멀티 쓰레드의) 동시간대에 일어나는 이슈에 대해 신경쓸 필요가 없기 때문에 코드를 한 층 간결하게 작성할 수 있다는 걸 의미한다. 하지만 동시에 메인 쓰레드의 블로킹 없는 네트워크 접근과 같은 긴 작업(long operations)들은 수행할 수 없다는 뜻이기도 하다.

예를 들어, 당신이 API로부터 어떤 데이터를 요청한다고 가정하자. 상황에 따라 서버는 요청을 처리하는데 다소 시간이 걸릴 수 있고, 이로 인한 블로킹은 웹페이지를 무응답 상태로 만들 수 있다. 

이 때, 자바스크립트의 비동기는 제 역할을 수행한다. 비동기 자바스크립트(콜백, 프로미스 등과 같은)를 사용하게 되면, 블로킹 없이 딜레이가 있는 네트워크 요청을 수행할 수 있게 된다.

팁: [Bit](https://bit.dev/)을 사용하는 것은 어떤 자바스크립트 코드든 간에 API로 만들어 준다. API로 만들게 되면, 앱간의 공유, 사용, 동기화가 용이해 더 빠르게 빌드하고 재사용하는데 유리해진다.  

# 자바스크립트의 동기적 방식
본격적으로 자바스크립트의 비동기적 작동 방식에 들어가기 앞서, 자바스크립트의 동기적인 코드 처리가 자바스크립트 엔진에서 어떤식으로 작동하는지 이해해보자.
```js
const second = () => {
  console.log('Hello there!');
}
const first = () => {
  console.log('Hi there!');
  second();
  console.log('The End');
}
first();
```
위 코드가 어떤 식으로 실행되는지 이해하기 위해, 우리는 **콜스택**의 **실행 컨텍스트**을 이해할 필요가 있다.

## 실행 컨텍스트(Excution Context)
실행 맥락이란, 자바스크립트가 평가되고 또 실행되는 환경이라는 추상적인 의미를 담고 있다. 자바스크립트의 코드를 실행한다는 것은 항상 어떠한 실행 맥락 속에서 동작한다는 것을 의미한다. 

따라서, 함수는 함수의 실행 컨텍스트에서 동작하고, 전역 코드는 전역 실행 컨텍스트에서 동작한다. 또한 모든 함수는 자신만의 실행 컨텍스트을 가지고 있다.

## 콜 스택
콜스택에는 코드가 실행되는 동안 모든 실행 컨텍스트를 저장하고, 이렇게 저장된 컨텍스트를 후입선출 방식으로 다룬다. (즉, 나중에 들어온 정보를 우선적으로 처리한다.)

이제 코드를 보면서 자바스크립트 엔진이 코드를 어떻게 처리하는지 이해해보자.
```js
const second = () => {
  console.log('Hello there!');
}
const first = () => {
  console.log('Hi there!');
  second();
  console.log('The End');
}
first();

```
![image](https://miro.medium.com/max/1000/1*DkG1a8f7rdl0GxM0ly4P7w.png)

## 동기적 방식 - 어떤 일이 일어나는가?
코드가 실행되면, 전역 실행 컨텍스트가 생성되고 콜스택의 맨 위에 들어간다. 이후 콜스택이 first()를 마주하게 되면, first()는 스택의 맨 위에 들어간다.

그 다음으로 console.log('Hi there!')이 콜스택의 맨 위로 들어가게되고, 바로 실행 후 콜스택에서 빠져나온다. 그러고 나면, second()가 콜스택에 들어가게되고, 이 함수가 콜스택에 들어간다.

second()가 들어가고 나서는 console.log('Hello there!')이 콜스택의 맨 위에 들어가게 되고, 앞서 그랬던 것 처럼 콘솔 로그가 실행되고 난 후 바로 빠져나가게 된다. 그러고 나면 second()함수의 할 일도 끝났기 때문에 마찬가지로 콜스택에서 빠져나간다.

마지막으로 console.log('The End')가 콜스택에 들어가서 실행 후, 빠져나가게 되고, 최초에 실행되었던 first()도 할 일을 마친 후 빠져나온다. 

마지막으로 전역 실행 컨텍스트가 빠져나간다.

# 자바스크립트 비동기적 방식
앞서 콜스택에 대한 기본적인 아이디어를 알아봤으니, 이제는 비동기로 돌아갈 차례이다.

## 블로킹이란?
우리가 이미지 처리나 네크워크 요청을 비동기적 방식으로 한다고 가정해보자.
```js
const processImage = (image) => {
  /**
  * doing some operations on image
  **/
  console.log('Image processed');
}
const networkRequest = (url) => {
  /**
  * requesting network resource
  **/
  return someData;
}
const greeting = () => {
  console.log('Hello World');
}
processImage(logo.jpg);
networkRequest('www.somerandomurl.com');
greeting();
```
이미지 처리나 네트워크 요청와 같은 일은 시간이 좀 걸린다. 그래서 `processImage()`함수를 실행하게 되면, 이미지의 크기에 따라 시간이 걸릴 수 있다.

만일 `processImage()`함수를 완료하면, 이는 스택에서 사라진다. 이후에는`networkRequest()`함수가 실행되고 콜스택에 들어간다. 마찬가지로 이 함수도 처리되기까지 시간이 걸린다.

오랜 기다림 끝에 `networkRequest()`함수가 완료되면, `greeting()`함수가 불려온다. 이 함수는 `console.log`만을 담고 있는데, 일반적으로 금방 처리되기 때문에 `greeting()`함수는 즉각 실행되고 콜스택에서 빠져나오게 된다.

보다시피, `processImage()`나 `networkRequest()`와 같은 함수를 처리하는 동안 기다려야만 한다. 다시 말하면, 이러한 함수들은 콜스택 또는 메인 쓰레드를 블로킹 하고 있다는 뜻이기도 하다. 그래서 코드가 실행되는 동안, 우리는 아무것도 할 수 없이 넋놓고 바라볼 수 밖에 없게 된다.

## 그래서, 해결책은 무엇?
가장 간단한 해결책은 비동기 콜백(asynchronous callbacks)이다. 우리는 비동기 콜백으로 코드를 논-블로킹 방식으로 구성할 수 있게 된다.
```js
const networkRequest = () => {
  setTimeout(() => {
    console.log('Async Code');
  }, 2000);
};
console.log('Hello World');
networkRequest();
```
여기서는 네트워크 요청처럼 보이기 위해 setTimeout메서드를 사용했다. 사실 setTimeout메서드가 자바스크립트 엔진의 일부분이 아닌, web APIs와 C/C++ APIs의 일부분이라는 사실을 기억할 필요가 있다.

이 코드가 어떻게 실행되는지 이해하기 위해, **이벤트 루프**와 **콜백 큐**(또는 task queue나 message queue라고 불리기도 한다.)와 같은 개념을 추가적으로 알아야만 한다.

![image](https://miro.medium.com/max/700/1*O_H6XRaDX9FaC4Q9viiRAA.png)

**이벤트 루프**와 **web APIs** 그리고 **message queue**(/task queue)는 자바스크립트 엔진의 일부분이 아니다. 이들은 자바스크립트 런타임 환경 또는 노드 런타임 환경의 일부다. 그리고 노드에서 web APIs는 C/C++ APIs로 대체된다.

이제 위에 있는 코드로 돌아가 어떻게 비동기적 방식으로 실행되는지 알아보자.

```js
const networkRequest = () => {
  setTimeout(() => {
    console.log('Async Code');
  }, 2000);
};
console.log('Hello World');
networkRequest();
console.log('The End');

```

![image](https://miro.medium.com/max/700/1*sOz5cj-_Jjv23njWg_-uGA.gif)

위 코드가 브라우저상에서 로드되면, `console.log('Hello World')`는 콜스택으로 들어가고 실행을 마치고 나면 바로 빠져나온다. 그리고 `networkRequest`를 마주치게 되고, 이 함수가 콜스택으로 들어간다.

이후 `setTimeout()`함수가 불려오고, 콜스택으로 들어간다. `setTimeout()`은 두가지 인자를 받을 수 있는데, 첫번째는 실행할 콜백함수, 두번째는 언제 실행될지 시간(milliseconds단위)이다.

위에서는 `setTimeout()`을 web APIs 환경에서 2초 후 실행되도록 설정했다. 여기서 `setTimeout()`은 실행을 마치고 콜스택에서 빠져나온다. 이후 `console.log('The End')`가 스택으로 들어오고 실행되고 나면 콜스택에서 빠져나온다.

위 과정이 이루어지는 동안, setTimeout의 callback은 message queue로 들어간다. 하지만, 이 콜백함수는 즉각적으로 실행되지 않고 대신에 이벤트 루프가 실행된다.

## 이벤트 루프
기본적으로 이벤트 루프가 하는 일은 콜스택이 비어있는지 아닌지 살펴보는 일이다. 만일 콜스택이 비어있다면, message queue에 (pending 상태인)실행되기를 기다리는 콜백 함수가 있는지를 살펴본다. (콜스택이 비워지고 나서야 콜백 함수를 실행한다는 뜻이다.)

위의 경우, message queue에는 (setTimeout의 인자로 들어갔던)콜백 함수 하나만을 가지고 있고, 콜스택은 비어있다. 따라서 이벤트 루프는 콜백 함수를 비어있는 콜스택으로 집어넣는다.

`console.log('Async Code')`가 스택으로 들어간 다음, 실행되고 나면 콜스택에서 사라진다. 그러고 나면 콜백 함수가 콜스택에서 빠져나가고, 최종적으로 프로그램이 종료된다.

## DOM 이벤트
**Message queue**에는 (클릭 이벤트나 키보드 이벤트와 같은)DOM의 이벤트에 붙어있는 콜백 함수도 담는다.

```js
document.querySelector('.btn').addEventListener('click',(event) => {
  console.log('Button Clicked');
});
```

DOM이벤트의 경우, 이벤트 리스너는 web APIs environment에 특정 이벤트가 발생할 때 까지 대기하고 있게 된다. 그리고 이벤트가 발생하게 되면, 그제서야 콜백 함수는 메세지 큐로 들어가게 된다.

콜백함수가 메세지 큐에 들어가고 난 뒤에, 이벤트 루프는 마찬가지로 콜스택이 비어있는지 확인한 후 콜백 함수를 콜스택에 집어 넣는다.

우리는 여기서 비동기적 콜백 함수와 DOM이벤트 둘 다 메세지 큐를 이용해 대기 상태인 콜백 함수를 실행한다는 것을 알 수 있다.


## ES6 job Queue와 Micro-task queue
ES6는 javascript Promise에 의해 사용되는 job queue(/micro-task queue)를 소개한다. job queue는 message queue보다 우선순위가 높다. 즉, job queue/micro-task queue안에 있는 Promise의 작업이 message queue안에 있는 콜백 함수보다 먼저 실행된다는 것이다.

예를 들어
```js
console.log('Script start');
setTimeout(() => {
  console.log('setTimeout');
}, 0);
new Promise((resolve, reject) => {
    resolve('Promise resolved');
  }).then(res => console.log(res))
    .catch(err => console.log(err));
console.log('Script End');
```
이 코드의 출력값은

```
Script start
Script End
Promise resolved
setTimeout
```

여기서 promise가 setTimeout보다 먼저 실행된다는 사실을 확인할 수 있는데, 이는 promise response가 message queue보다 우선적으로 처리되는 micro-task queue에 있기 때문이다.

또 다른 예로, 두개의 프로미스와 setTimeout을 보자.

```js
console.log('Script start');
setTimeout(() => {
  console.log('setTimeout 1');
}, 0);
setTimeout(() => {
  console.log('setTimeout 2');
}, 0);
new Promise((resolve, reject) => {
    resolve('Promise 1 resolved');
  }).then(res => console.log(res))
    .catch(err => console.log(err));
new Promise((resolve, reject) => {
    resolve('Promise 2 resolved');
  }).then(res => console.log(res))
    .catch(err => console.log(err));
console.log('Script End');
```

이 코드의 출력값은

```
Script start
Script End
Promise 1 resolved
Promise 2 resolved
setTimeout 1
setTimeout 2
```

이번에는 setTimeout1,2앞에 두개의 프로미스가 실행된 사실을 확인할 수 있다. 이는 이벤트 루프가 micro-task queue를 우선적으로 처리하기 때문에 일어난 일이다.

promise가 resolve되면, micro-task큐에 쌓이게 되고 이벤트 루프는 이 작업들을 실행하게 된다. 이벤트 루프가 이러한 과정을 수행하는 동안에, message 큐에 있는 콜백 함수들은 계속해서 기다려야만 한다.

```js
console.log('Script start');
setTimeout(() => {
  console.log('setTimeout');
}, 0);
new Promise((resolve, reject) => {
    resolve('Promise 1 resolved');
  }).then(res => console.log(res));
new Promise((resolve, reject) => {
  resolve('Promise 2 resolved');
  }).then(res => {
       console.log(res);
       return new Promise((resolve, reject) => {
         resolve('Promise 3 resolved');
       })
     }).then(res => console.log(res));
console.log('Script End');
```

출력값

```
Script start
Script End
Promise 1 resolved
Promise 2 resolved
Promise 3 resolved
setTimeout
```

그래서 모든 micro task 큐에 있는 작업들은 message 큐에 있는 작업들에 우선한다. 즉, 이벤트 루프는 micro-task에 있는 작업들을 비우고 나서야 message 큐에 있는 콜백 함수들을 실행한다.
