---
title: Event Loop & Asyn
date: "2020-09-18"
description: 
---
# 1. Event Loop + 논 블로킹 I/O
<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop">동시성 모델 및 이벤트 루프</a>

## 1.1 이벤트 루프란?
- 이벤트 발생시 호출할 콜백함수를 관리하고
- 그 콜백 함수의 실행 순서를 결정함.
- 이러한 과정을 노드가 종료될 때 까지 반복(Loop)

## 1.2 이벤트 루프의 구체적인 흐름
이를 알기 위해서는 세가지가 있다는 사실을 알아야함.
### (1) 메모리(Heap)
- 메모리: 스크립트를 읽으면서 정의된 애들을 기억해놓는 장소
### (2) 호출스택
- 호출스택: 호출부분을 만나면 Stack 자료구조(후입선출)로 쌓아올림.
### (3) 백그라운드
- 비동기 함수가 실행되면 백그라운드로 이동하게 됨
	- 비동기 함수의 대표적인 예로 setTimeout()과 같은게 있음
- 백그라운드는 들어온 순서 상관없이 태스크 큐로 보냄.
	- 따라서 들어온 순서대로 실행될 꺼라고 기대하면 안됨.
### (4) 태스크 큐
- 백그라운드의 실행을 받아서 호출스택 내 모든 함수가 끝날 때까지 대기함
	- 따라서 호출 스택에 함수가 많으면, setTimeout과 같은 함수가 제 때 실행이 되지 않을수도 있음.
- 끝나고 나면 태스크 큐에 있는 내용이 호출 스택으로 이동 후 실행.

## 1.3 논 블로킹 I/O
- 논 블로킹: 이전 작업이 완료될 때까지 대기하지않고 다음 작업을 수행
- I/O : Input과 Output을 의미함.

논 블로킹으로 처리한다는 것은 작업을 백그라운드로 넘겨서 처리한다는 것을 뜻함. (작업의 제어권을 넘겨줌)

### 블로킹, 논 블로킹 vs 동기, 비동기
- 블로킹, 논 블로킹: 일의 진행되다가 막히는지 안막히는지의 관점
	- 블로킹: 호출 받은 애가 return안하고 일 처리
		- 카톡 받으면 안읽씹하고 할 일 하는 스타일
	- 논 블로킹: 호출 받은 애가 return해서 제어권을 넘겨줌
		- 카톡 받으면 무조건 읽고 바로 답장해야 직성이 풀리는 스타일

- 동기 비동기: 동시에 일이 진행되는지 아닌지의 관점
	- 동기: 호출한 애가 호출 받은 친구의 return여부 신경
		- 카톡 보내면 답장 안받고는 일에 집중 못하는 스타일
	- 비동기: 호출한 애가 호출 받은 친구의 return여부 신경x
		- 카톡 보내고 나면 답장 하든 말든 신경 안쓰는 스타일

</br>

# 2. 비동기 함수

## 2.1 비동기 전달 패턴
### (1) callback패턴
```js
let request = 'caffelatte';
orderCoffeeAsync(request, function(response){
	drink(response);
})
```

### (2) 이벤트 등록 패턴
```js
let request = 'caffelatte';
orderCoffeeAsync(request).onready = function(response){
	drink(response);
}
```
#### - 함수 연결
- 맞는 방식 : 함수 자체를 연결시킨다.

```js
document.querySelector('#btn').onclikc = handleClick;
document.querySelector('#btn').onclikc = handleClick.bind();
document.querySelector('#btn').onclikc = function(){
	handleClick();
}
```

- 틀린 방식 : 함수 '실행'을 연결시킨다.

```js
document.querySelector('#btn').onclikc = handleClick();
```

## 2.3 비동기 주요 사례
### (1) DomElement 이벤트 핸들러
마우스, 키보드 입력(click, keydown)
페이지 로딩(DomcontentLoaded)

### (2) 타이머
- 타이머  api(setTimeout)
- 애니메이션 api(requestAnimationFrame)

setTimeout(callback, millisecond): 일정 시간 후 실행
setInterval(callback, millisecond): 일정 시간 간격을 가지고 함수를 반복 실행(비동기라 스크립트 읽어낸 후에도 지속적으로 움직임)
clearInterval(timerld): 반복 실행되던 녀석을 지움 (단, setTimeout이 변수 설정 되어 있어야 가능)
```js
let reload = setInterval(callvback, millisecond)
clearInterval(reload)
```
### (3) 서버에 자원 요청 및 응답
- fetch API
- AJAX(XHR)

## 2.4 비동기 함수 작동 원리
event loop
developer.mozilla.org/ko/docks/JavaScript/EventLoop

philip roberts: help, i'm stuck in an event-loop
vimeo.com/96425312


# 3. 프로미스

## 
```js
const = condition = true;
const = promise = new Promise((resolve, reject) => {	// resolve와 reject는 각각 .then과 .catch의 인자로 들어감
	if(condition){
		resolve('성공');
	}else{
		reject('실패');
	}
})
promise
	.then( message => {	// resolve가 인자로 들어감(여기서는 message파라미터의)
		console.log('성공(resolve)한 경우 실행')
	})
	.catch( error => {	//reject가 인자로 들어감(여기서는 error파라미터의)
		console.log('실패(reject)한 경우 실행')
	})
	.finally(() => {
		console.log('무조건 실행. ')
	})
```
