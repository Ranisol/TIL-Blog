---
title: (Nodejs) 2. Event Loop & Asyn
date: "2020-09-19"
description: 
---
# 1. Event Loop + 논블로킹, 비동기
<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop">동시성 모델 및 이벤트 루프</a>

## 1.1 동기 비동기
- 동기 비동기: 동시에 일이 진행되는지 아닌지의 관점
	- 동기: 호출한 애가 호출 받은 친구의 return여부 신경
		- 카톡 보내면 답장 안받고는 일을 못함
	- 비동기: 호출한 애가 호출 받은 친구의 return여부 신경x
		- 카톡 보내고 나면 답장 하든 말든 신경 안쓰고 할꺼 함.

## 1.2 블로킹, 논 블로킹
- 블로킹, 논 블로킹: 일의 진행되다가 막히는지 안막히는지의 관점
	- 블로킹: 호출 받은 애가 return안하고 일 처리
		- 카톡 받으면 안읽씹하고 할 일 함
	- 논 블로킹: 호출 받은 애가 return해서 제어권을 넘겨줌
		- 카톡 받으면 무조건 읽고 바로 답장 후 할꺼 함.


## 1.3 이벤트 루프의 흐름
- 이벤트 루프란, 이벤트 발생시 호출할 콜백함수를 관리하고, 그 콜백 함수의 실행 순서를 결정하는 과정을 말한다.. 이러한 과정을 노드가 종료될 때 까지 반복한다.
- 이벤트 루프는 다음의 과정을 거쳐 실행된다.
### (1) 메모리(Heap)
- 메모리: 스크립트를 읽으면서 정의된 애들을 기억해놓는 장소
### (2) 호출스택
- 호출스택: 호출부분을 만나면 Stack 자료구조(후입선출)로 쌓아올림.
### (3) 백그라운드
- 비동기 함수가 실행되면 백그라운드로 이동하게 됨
	- 비동기 함수의 대표적인 예로 setTimeout()과 같은게 있음
- 백그라운드는 들어온 순서 상관없이 태스크 큐로 보냄.
	- 따라서 들어온 순서대로 실행될 꺼라고 기대하면 안됨.
### (4) 태스크 큐
- 백그라운드의 실행을 받아서 호출스택 내 모든 함수가 끝날 때까지 대기함
	- 따라서 호출 스택에 함수가 많으면, setTimeout과 같은 함수가 제 때 실행이 되지 않을수도 있음.
- 끝나고 나면 태스크 큐에 있는 내용이 호출 스택으로 이동 후 실행.

## 1.4 이벤트 루프와 비동기 함수
- 이벤트 루프에서 비동기함수가 왜 중요할까? 

이벤트 루프에서 보다시피, 비동기 함수는 백그라운드로 간다. 금방 처리가 되는 작업뿐이라면, 호출 스택에 쌓아놓고 모두 처리하면 된다. 하지만 딜레이가 생기는 작업이라면 호출스택의 아랫단에 있는 작업들은 딜레이가 발생한 작업때문에 처리가 안되는 상황이 생긴다.

이러한 상황을 해결하기 위해서, 딜레이가 있는 작업은 백그라운드로 보내고 그렇지 않은 작업은 호출스택에서 즉각적으로 작업을 처리하는 방법을 택할 수 있다. 여기서 백그라운드로 작업을 보내기 위해 비동기 함수를 사용할 수 있다.


</br>

# 2. 비동기 함수


## 2.1 비동기 전달 패턴
### (1) callback패턴
```js
const printString = (string) => {
  setTimeout(() => {console.log(string)},
    Math.floor(Math.random() * 100) + 1
  )}
  const printAll = () => {
    printString('a')
    printString('b')
    printString('c')
  }
```
=> 이렇게 하면, 순서를 따르지 않고 실행됨.

```js
const printString = (string, callback) => {
  setTimeout(() => {console.log(string)
      callback()
    },
    Math.floor(Math.random() * 100) + 1
  )}
  const printAll = () => {
    printString('a', () => {
      printString('b', () => {
        printString('c', () => {})
      })
    })
  }

```
=> 반면, 이렇게 하면 순서를 따라 실행됨.

### (2) 이벤트 등록 패턴
```js
let request = 'caffelatte';
orderCoffeeAsync(request).onready = function(response){
	drink(response);
}
```
또는 

```js
document.querySelector('#btn').onclikc = handleClick;
document.querySelector('#btn').onclikc = handleClick.bind();
document.querySelector('#btn').onclikc = function(){
	handleClick();
}
```


## 2.3 비동기 주요 사례
### (1) DomElement 이벤트 핸들러
마우스, 키보드 입력(click, keydown)
페이지 로딩(DomcontentLoaded)

### (2) 타이머
- 타이머  api(setTimeout)
- 애니메이션 api(requestAnimationFrame)

setTimeout(callback, millisecond): 일정 시간 후 실행
setInterval(callback, millisecond): 일정 시간 간격을 가지고 함수를 반복 실행(비동기라 스크립트 읽어낸 후에도 지속적으로 움직임)
clearInterval(timerld): 반복 실행되던 녀석을 지움 (단, setTimeout이 변수 설정 되어 있어야 가능)
```js
let reload = setInterval(callvback, millisecond)
clearInterval(reload)
```

# 3. 비동기 작업 업그레이드

## 3.1 콜백지옥
아래와 같은 상황에서 좀 더 코드를 간결하게 만들기 위한 노력이 있다.
```js
  const printAll = () => {
    printString('a', () => {
      printString('b', () => {
        printString('c', () => {})
      })
    })
  }
```

## 3.2 해결책1: Promise
- 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과값을 나타냄.

### (1) Promise 선언 및 사용
```js
const condition = true;
const promise = new Promise((resolve, reject) => {	// resolve와 reject는 각각 .then과 .catch의 인자로 들어감
	if(condition){
		resolve('성공');
	}else{
		reject('실패');
	}
})
promise
	.then( message => {	// resolve가 인자로 들어감(여기서는 message파라미터의)
		console.log('성공(resolve)한 경우 실행')
	})
	.catch( error => {	//reject가 인자로 들어감(여기서는 error파라미터의)
		console.log('실패(reject)한 경우 실행')
	})
	.finally(() => {
		console.log('무조건 실행. ')
	})
```
- Resolve(성공 리턴 값) => then으로 연결됨
- Reject(실패 리턴 값) => catch로 연결됨

### (2) Promise 연달아 사용
```js
promise
  .then((message) => {
    return new Promise((resolve, reject) => {
      resolve(message);
    });
  })
  .then((message2) => {
    console.log(message2);
    return new Promise((resolve, reject) => {
      resolve(message2);
    });
  })
  .then((message3) => {
    console.log(message3);
  })
  .catch((error) => {
    console.error(error);
  });
```
- 참고로 then메서드는 다음과 같이 동일한 인자를 여러 차례 받을 수 있음. 이렇게 받아서 각각의 then마다 다른 방식으로 처리하는 게 가능.

```js
function findAndSaveUser(Users) {
  Users.findOne({})
    .then((user) => {
      user.name = 'zero';
      return user.save();
    })
    .then((user) => {
      return Users.findOne({ gender: 'm' });
    })
    .then((user) => {
      // 생략
    })
    .catch(err => {
      console.error(err);
    });
}
```

### (3) Promise.all

```js
const promise1 = Promise.resolve('성공1');
const promise2 = Promise.resolve('성공2');
Promise.all([promise1, promise2])
  .then((result) => {
    console.log(result); // ['성공1', '성공2'];
  })
  .catch((error) => {
    console.error(error);
  });

```

## 3.3 해결책2: async / await
- then 대신, await키워드를 이용해 user변수에 대한 처리를 할 수 있음.

### (1) then => await
```js
async function findAndSaveUser(Users) { // const findAndSaveUser = async (Users) => 와 같은 방식도 가능.
  try {
    let user = await Users.findOne({});
    user.name = 'zero';
    user = await user.save();
    user = await Users.findOne({ gender: 'm' });
    // 생략
  } catch (error) {
    console.error(error);
  }
}
```

### (2) promise.all => for await of
```js
const promise1 = Promise.resolve('성공1');
const promise2 = Promise.resolve('성공2');
(async () => {
  for await (promise of [promise1, promise2]) {
    console.log(promise);
  }
})();
```

